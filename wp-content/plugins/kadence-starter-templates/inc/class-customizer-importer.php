<?php
/**
 * Class for downloading a file from a given URL.
 *
* @package Kadence Starter Templates
 */

namespace KadenceWP\KadenceStarterTemplates;

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

class CustomizerImporter {
	/**
	 * Import customizer from a DAT file, generated by the Customizer Export/Import plugin.
	 *
	 * @param string $customizer_import_file_path path to the customizer import file.
	 */
	public static function import( $customizer_import_file_path ) {
		$starter_templates = Starter_Templates::get_instance();
		$log_file_path     = $starter_templates->get_log_file_path();

		// Try to import the customizer settings.
		$results = self::import_customizer_options( $customizer_import_file_path );

		// Check for errors, else write the results to the log file.
		if ( is_wp_error( $results ) ) {
			$error_message = $results->get_error_message();

			// Add any error messages to the frontend_error_messages variable in starter_templates main class.
			$starter_templates->append_to_frontend_error_messages( $error_message );
			if ( apply_filters( 'kadence_starter_templates_save_log_files', false ) ) {
				// Write error to log file.
				Helpers::append_to_file(
					$error_message,
					$log_file_path,
					esc_html__( 'Importing customizer settings', 'kadence-starter-templates' )
				);
			}
		} else {
			if ( apply_filters( 'kadence_starter_templates_save_log_files', false ) ) {
				// Add this message to log file.
				$log_added = Helpers::append_to_file(
					esc_html__( 'Customizer settings import finished!', 'kadence-starter-templates' ),
					$log_file_path,
					esc_html__( 'Importing customizer settings' , 'kadence-starter-templates' )
				);
			}
		}
	}

	/**
	 * Import customizer from a DAT file, generated by the Customizer Export/Import plugin.
	 *
	 * @param string $customizer_import_file_path path to the customizer import file.
	 */
	public static function import_color( $customizer_import_file_path ) {
		// Try to import the customizer settings.
		$results = self::import_customizer_options_only_color( $customizer_import_file_path );
	}
	/**
	 * Import customizer from a DAT file, generated by the Customizer Export/Import plugin.
	 *
	 * @param string $customizer_import_file_path path to the customizer import file.
	 */
	public static function import_font( $customizer_import_file_path ) {
		// Try to import the customizer settings.
		$results = self::import_customizer_options_fonts_only( $customizer_import_file_path );
	}


	/**
	 * Imports uploaded mods and calls WordPress core customize_save actions so
	 * themes that hook into them can act before mods are saved to the database.
	 *
	 * Update: WP core customize_save actions were removed, because of some errors.
	 *
	 * @since 1.1.1
	 * @param string $import_file_path Path to the import file.
	 * @return void|WP_Error
	 */
	public static function import_customizer_options( $import_file_path ) {
		// Setup global vars.
		global $wp_customize;

		// Setup internal vars.
		$template = get_template();

		// Make sure we have an import file.
		if ( ! file_exists( $import_file_path ) ) {
			return new \WP_Error(
				'missing_cutomizer_import_file',
				sprintf(
					esc_html__( 'Error: The customizer import file is missing! File path: %s', 'kadence-starter-templates' ),
					$import_file_path
				)
			);
		}
		// Get the upload data.
		$raw = Helpers::data_from_file( $import_file_path );

		// Make sure we got the data.
		if ( is_wp_error( $raw ) ) {
			return $raw;
		}

		$data = unserialize( $raw, array( 'allowed_classes' => false ) );
		// Data checks.
		if ( 'array' != gettype( $data ) && ( ! isset( $data['template'] ) || ! isset( $data['mods'] ) ) ) {
			return new \WP_Error(
				'customizer_import_data_error',
				esc_html__( 'Error: The customizer import file is not in a correct format. Please make sure to use the correct customizer import file.', 'kadence-starter-templates' )
			);
		}
		if ( $data['template'] !== $template ) {
			return new \WP_Error(
				'customizer_import_wrong_theme',
				esc_html__( 'Error: The customizer import file is not suitable for current theme. You can only import customizer settings for the same theme or a child theme.', 'kadence-starter-templates' )
			);
		}

		// Import images.
		if ( apply_filters( 'kadence-starter-templates/customizer_import_images', true ) ) {
			$data['mods'] = self::import_customizer_images( $data['mods'] );
		}

		// Import custom options.
		if ( isset( $data['options'] ) ) {
			// Require modified customizer options class.
			if ( ! class_exists( '\WP_Customize_Setting' ) ) {
				require_once ABSPATH . 'wp-includes/class-wp-customize-setting.php';
			}
			if ( ! class_exists( 'Kadence_Starter_Templates\CustomizerOption' ) ) {
				require_once KADENCE_STARTER_TEMPLATES_PATH . 'inc/class-customizer-option.php';
			}
			foreach ( $data['options'] as $option_key => $option_value ) {
				if ( 'kadence_global_palette' === $option_key ) {
					$palette = json_decode( $option_value, 'true' );
					$info = update_option( 'kadence_global_palette', json_encode( $palette ) );
					if ( ! $info ) {
						$info = add_option( 'kadence_global_palette', json_encode( $palette ) );
					}
				} else {
					$option = new CustomizerOption( $wp_customize, $option_key, array(
						'default'    => '',
						'type'       => 'option',
						'capability' => 'manage_options',
					) );
					$option->import( $option_value );
				}
			}
		}

		// If wp_css is set then import it.
		if ( function_exists( 'wp_update_custom_css_post' ) && isset( $data['wp_css'] ) && '' !== $data['wp_css'] ) {
			wp_update_custom_css_post( $data['wp_css'] );
		}

		// Should the customizer import use the WP customize_save* hooks?
		$use_wp_customize_save_hooks = apply_filters( 'kadence-starter-templates/enable_wp_customize_save_hooks', false );

		if ( $use_wp_customize_save_hooks ) {
			do_action( 'customize_save', $wp_customize );
		}

		// Loop through the mods and save the mods.
		foreach ( $data['mods'] as $key => $val ) {
			if ( $use_wp_customize_save_hooks ) {
				do_action( 'customize_save_' . $key, $wp_customize );
			}

			set_theme_mod( $key, $val );
		}

		if ( $use_wp_customize_save_hooks ) {
			do_action( 'customize_save_after', $wp_customize );
		}

		do_action( 'kadence-starter-templates/after_customizer_import', $data );
	}

	/**
	 * Imports uploaded mods and calls WordPress core customize_save actions so
	 * themes that hook into them can act before mods are saved to the database.
	 *
	 * Update: WP core customize_save actions were removed, because of some errors.
	 *
	 * @since 1.1.1
	 * @param string $import_file_path Path to the import file.
	 * @return void|WP_Error
	 */
	public static function import_customizer_options_fonts_only( $import_file_path ) {
		// Setup global vars.
		global $wp_customize;

		// Setup internal vars.
		$template = get_template();

		// Make sure we have an import file.
		if ( ! file_exists( $import_file_path ) ) {
			return new \WP_Error(
				'missing_cutomizer_import_file',
				sprintf(
					esc_html__( 'Error: The customizer import file is missing! File path: %s', 'kadence-starter-templates' ),
					$import_file_path
				)
			);
		}
		// Get the upload data.
		$raw = Helpers::data_from_file( $import_file_path );

		// Make sure we got the data.
		if ( is_wp_error( $raw ) ) {
			return $raw;
		}

		$data = unserialize( $raw, array( 'allowed_classes' => false ) );

		// Data checks.
		if ( 'array' != gettype( $data ) && ( ! isset( $data['template'] ) || ! isset( $data['mods'] ) ) ) {
			return new \WP_Error(
				'customizer_import_data_error',
				esc_html__( 'Error: The customizer import file is not in a correct format. Please make sure to use the correct customizer import file.', 'kadence-starter-templates' )
			);
		}
		if ( $data['template'] !== $template ) {
			return new \WP_Error(
				'customizer_import_wrong_theme',
				esc_html__( 'Error: The customizer import file is not suitable for current theme. You can only import customizer settings for the same theme or a child theme.', 'kadence-starter-templates' )
			);
		}

		// Loop through the mods and save the mods.
		foreach ( $data['mods'] as $key => $val ) {
			if ( $key === 'heading_font' || $key === 'base_font' ) {
				set_theme_mod( $key, $val );
			}
		}
	}

	/**
	 * Imports uploaded mods and calls WordPress core customize_save actions so
	 * themes that hook into them can act before mods are saved to the database.
	 *
	 * Update: WP core customize_save actions were removed, because of some errors.
	 *
	 * @since 1.1.1
	 * @param string $import_file_path Path to the import file.
	 * @return void|WP_Error
	 */
	public static function import_customizer_options_only_color( $import_file_path ) {
		// Setup global vars.
		global $wp_customize;

		// Setup internal vars.
		$template = get_template();

		// Make sure we have an import file.
		if ( ! file_exists( $import_file_path ) ) {
			return new \WP_Error(
				'missing_cutomizer_import_file',
				sprintf(
					esc_html__( 'Error: The customizer import file is missing! File path: %s', 'kadence-starter-templates' ),
					$import_file_path
				)
			);
		}
		// Get the upload data.
		$raw = Helpers::data_from_file( $import_file_path );

		// Make sure we got the data.
		if ( is_wp_error( $raw ) ) {
			return $raw;
		}

		$data = unserialize( $raw, array( 'allowed_classes' => false ) );

		// Data checks.
		if ( 'array' != gettype( $data ) && ( ! isset( $data['template'] ) || ! isset( $data['mods'] ) ) ) {
			return new \WP_Error(
				'customizer_import_data_error',
				esc_html__( 'Error: The customizer import file is not in a correct format. Please make sure to use the correct customizer import file.', 'kadence-starter-templates' )
			);
		}
		// Import custom options.
		if ( isset( $data['options'] ) ) {
			foreach ( $data['options'] as $option_key => $option_value ) {
				if ( 'kadence_global_palette' === $option_key ) {
					$palette = json_decode( $option_value, 'true' );
					update_option( 'kadence_global_palette', json_encode( $palette ) );
				}
			}
		}
	}

	/**
	 * Helper function: Customizer import - imports images for settings saved as mods.
	 *
	 * @since 1.1.1
	 * @param array $mods An array of customizer mods.
	 * @return array The mods array with any new import data.
	 */
	private static function import_customizer_images( $mods ) {
		foreach ( $mods as $key => $val ) {
			if ( !empty( $val ) && is_array( $val ) ) {
				foreach ( $val as $sub_key => $sub_val ) {
					if ( !empty( $sub_val ) && is_string( $sub_val ) ) {
						$new_val = self::customizer_image_transform( $sub_val );
						if ( $new_val !== $sub_val ) {
							$mods[ $key ][ $sub_key ] = $new_val;
						}
					} else if ( !empty( $sub_val ) && is_array( $sub_val ) ) {
						foreach ( $sub_val as $sub_sub_key => $sub_sub_val ) {
							if ( !empty( $sub_sub_val ) && is_string( $sub_sub_val ) ) {
								$new_val = self::customizer_image_transform( $sub_sub_val );
								if ( $new_val !== $sub_sub_val ) {
									$mods[ $key ][ $sub_key ][ $sub_sub_key ] = $new_val;
								}
							} else if ( !empty( $sub_sub_val ) && is_array( $sub_sub_val ) ) {
								foreach ( $sub_sub_val as $sub_sub_sub_key => $sub_sub_sub_val ) {
									if ( !empty( $sub_sub_sub_val ) && is_string( $sub_sub_sub_val ) ) {
										$new_val = self::customizer_image_transform( $sub_sub_sub_val );
										if ( $new_val !== $sub_sub_sub_val ) {
											$mods[ $key ][ $sub_key ][ $sub_sub_key ][ $sub_sub_sub_key ] = $new_val;
										}
									}
								}
							}
						}
					}
				}
			} else if ( !empty( $val ) && is_string( $val ) ) {
				$new_val = self::customizer_image_transform( $val );
				if ( $new_val !== $val ) {
					$mods[ $key ] = $new_val;
				}
			}
		}
		return $mods;
	}
	/**
	 * Helper function: Customizer import - imports images for settings saved as mods.
	 *
	 * @since 1.1.1
	 * @param array $mods An array of customizer mods.
	 * @return array The mods array with any new import data.
	 */
	private static function customizer_image_transform( $maybe_image_url ) {
		// Check if val is a string.
		if ( is_string( $maybe_image_url ) ) {
			if ( self::customizer_is_image_url( $maybe_image_url ) ) {
				$url_already = self::customizer_check_for_image( $maybe_image_url );
				if ( $url_already ) {
					return $url_already;
				} else {
					$data = self::customizer_sideload_image( $maybe_image_url );
					if ( ! is_wp_error( $data ) && isset( $data->url ) ) {
						return $data->url;
					}
				}
			}
		}

		return $maybe_image_url;
	}

	/**
	 * Helper function: Sideload Image import
	 * Taken from the core media_sideload_image function and
	 * modified to return an array of data instead of html.
	 *
	 * @since 1.1.1.
	 * @param string $file The image file path.
	 * @return array An array of image data.
	 */
	private static function customizer_check_for_image( $file ) {
		if ( ! empty( $file ) ) {
			preg_match( '/[^\?]+\.(jpe?g|jpe|gif|png|webp|mp4)\b/i', $file, $matches );
			$file_name = basename( $matches[0] );
			$ext = array( ".png", ".jpg", ".gif", ".jpeg", ".webp", ".mp4" );
			$clean_filename = str_replace( $ext, "", $file_name );
			$clean_filename = trim( html_entity_decode( sanitize_title( $clean_filename ) ) );
			if ( post_exists( $clean_filename ) ) {
				$attachment = self::get_page_by_title( $clean_filename, OBJECT, 'attachment' );
				if ( ! empty( $attachment ) ) {
					return wp_get_attachment_url( $attachment->ID );
				}
			} else {
				$attachment_id = self::get_image_id_by_filename( $file_name );
				if ( ! empty( $attachment_id ) ) {
					return wp_get_attachment_url( $attachment_id );
				}
			}
		}
		return false;
	}

	/**
	 * Get the ID of an attachment by its filename.
	 *
	 * @param string $filename The filename of the image (e.g., 'my-image.jpg').
	 * @return int|null The attachment ID if found, otherwise null.
	 */
	public static function get_image_id_by_filename( $filename ) {
		global $wpdb;

		if ( empty( $filename ) ) {
			return null;
		}
		$post_id = $wpdb->get_var(
			$wpdb->prepare(
				"SELECT post_id FROM {$wpdb->postmeta} WHERE meta_key = '_wp_attached_file' AND meta_value LIKE %s",
				'%' . $wpdb->esc_like( $filename )
			)
		);
		if ( $post_id ) {
			return (int) $post_id;
		}

		return null;
	}
	/**
	 * Get Page by title.
	 *
	 * @param string $page_title The title of the page to get.
	 * @param string $output The output type.
	 * @param string $post_type The post type to get.
	 * @return array|object|null The page data.
	 */
	public static function get_page_by_title( $page_title, $output = OBJECT, $post_type = 'page' ) {
		$query = new \WP_Query(
			array(
				'post_type'              => $post_type,
				'title'                  => $page_title,
				'post_status'            => 'all',
				'posts_per_page'         => 1,
				'no_found_rows'          => true,
				'ignore_sticky_posts'    => true,
				'update_post_term_cache' => false,
				'update_post_meta_cache' => false,
				'orderby'                => 'date',
				'order'                  => 'ASC',
			)
		);

		if ( ! empty( $query->post ) ) {
			$_post = $query->post;

			if ( ARRAY_A === $output ) {
				return $_post->to_array();
			} elseif ( ARRAY_N === $output ) {
				return array_values( $_post->to_array() );
			}

			return $_post;
		}

		return null;
	}

	/**
	 * Helper function: Customizer import
	 * Taken from the core media_sideload_image function and
	 * modified to return an array of data instead of html.
	 *
	 * @since 1.1.1.
	 * @param string $file The image file path.
	 * @return array An array of image data.
	 */
	private static function customizer_sideload_image( $file ) {
		$data = new \stdClass();

		if ( ! function_exists( 'media_handle_sideload' ) ) {
			require_once( ABSPATH . 'wp-admin/includes/media.php' );
			require_once( ABSPATH . 'wp-admin/includes/file.php' );
			require_once( ABSPATH . 'wp-admin/includes/image.php' );
		}
		if ( ! empty( $file ) ) {
			// Set variables for storage, fix file filename for query strings.
			preg_match( '/[^\?]+\.(jpe?g|jpe|gif|png|webp)\b/i', $file, $matches );
			$file_array = array();
			$file_array['name'] = basename( $matches[0] );

			// Download file to temp location.
			$file_array['tmp_name'] = download_url( $file );

			// If error storing temporarily, return the error.
			if ( is_wp_error( $file_array['tmp_name'] ) ) {
				return $file_array['tmp_name'];
			}

			// Do the validation and storage stuff.
			$id = media_handle_sideload( $file_array, 0 );

			// If error storing permanently, unlink.
			if ( is_wp_error( $id ) ) {
				unlink( $file_array['tmp_name'] );
				return $id;
			}

			// Build the object to return.
			$meta                = wp_get_attachment_metadata( $id );
			$data->attachment_id = $id;
			$data->url           = wp_get_attachment_url( $id );
			$data->thumbnail_url = wp_get_attachment_thumb_url( $id );
			$data->height        = $meta['height'];
			$data->width         = $meta['width'];
		}

		return $data;
	}

	/**
	 * Checks to see whether a string is an image url or not.
	 *
	 * @since 1.1.1
	 * @param string $string The string to check.
	 * @return bool Whether the string is an image url or not.
	 */
	private static function customizer_is_image_url( $string = '' ) {
		if ( is_string( $string ) ) {
			if ( preg_match( '/\.(jpg|jpeg|png|webp|gif)/i', $string ) ) {
				return true;
			}
		}

		return false;
	}
}
